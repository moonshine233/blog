-- MySQL dump 10.13  Distrib 5.6.47, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.6.47

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `hibernate_sequence`
--

DROP TABLE IF EXISTS `hibernate_sequence`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `hibernate_sequence` (
  `next_val` bigint(20) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `hibernate_sequence`
--

LOCK TABLES `hibernate_sequence` WRITE;
/*!40000 ALTER TABLE `hibernate_sequence` DISABLE KEYS */;
INSERT INTO `hibernate_sequence` VALUES (26),(26),(26),(26),(26);
/*!40000 ALTER TABLE `hibernate_sequence` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL,
  `appreciation` bit(1) DEFAULT NULL,
  `commentabled` bit(1) DEFAULT NULL,
  `content` longtext,
  `create_time` datetime DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) DEFAULT NULL,
  `recommend` bit(1) DEFAULT NULL,
  `share_statement` bit(1) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (8,NULL,NULL,'# hiahiahia','2019-10-03 18:10:55','纪念我的第一篇博客','http://pic.51yuansu.com/pic3/cover/01/21/15/59059b1620f8a_610.jpg','原创','','','','我的第一篇博客','2019-10-03 19:37:13',22,2,3),(14,NULL,NULL,'## 实际需求\r\n\r\n编写的五子棋程序中，有存盘和续上盘的功能。该二维数组很多是默认值为0，记录了很多无意义数。\r\n\r\n## 代码编写\r\n\r\n```java\r\npublic class SparseArray {\r\n\r\n    public static void main(String[] args) {\r\n        //定义原始数组\r\n        int chessArr[][]=new int [11][11];\r\n        chessArr[1][2]=1;\r\n        chessArr[2][3]=2;\r\n        //输出原始数组\r\n        System.out.println(\"原始矩阵为~~~\");\r\n        for (int[] row : chessArr){\r\n            for (int i:row){\r\n                System.out.print(i+\"  \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        int sum=0;//记录有效数据个数\r\n        for (int i = 0; i < 11; i++) {\r\n            for (int j = 0; j < 11; j++) {\r\n                if (chessArr[i][j]!=0){\r\n                    sum++;\r\n                }\r\n            }\r\n        }\r\n        //定义稀疏数组\r\n        int sparseArr[][] =new int[sum+1][3];\r\n        sparseArr[0][0]=11;\r\n        sparseArr[0][1]=11;\r\n        sparseArr[0][2]=sum;\r\n        int count=0;//记录当前稀疏数组位置\r\n        //生成稀疏数组\r\n        for (int i = 0; i < 11; i++) {\r\n            for (int j = 0; j < 11; j++) {\r\n                if (chessArr[i][j]!=0){\r\n                    count++;\r\n                    sparseArr[count][0]=i;\r\n                    sparseArr[count][1]=j;\r\n                    sparseArr[count][2]=chessArr[i][j];\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"稀疏矩阵为~~~\");\r\n        //输出稀疏数组\r\n        for (int i = 0; i < sum+1; i++) {\r\n            for (int j = 0; j < 3; j++) {\r\n                System.out.print(sparseArr[i][j]+\"   \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        //定义恢复的原始数组\r\n        int chessArr1[][] =new int[sparseArr[0][0]][sparseArr[0][1]];\r\n        for (int i=0;i<sparseArr[0][0];i++){\r\n            for (int j = 0; j < sparseArr[0][1]; j++) {\r\n                chessArr1[i][j]=0;\r\n            }\r\n        }\r\n        //赋值\r\n        for (int i = 1; i < sum+1; i++) {\r\n            chessArr1[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];\r\n        }\r\n        //输出\r\n        System.out.println(\"恢复的原始矩阵为~~~\");\r\n        for (int[] row : chessArr1){\r\n            for (int i:row){\r\n                System.out.print(i+\"  \");\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 输出结果\r\n\r\n```\r\n\r\n原始矩阵为~~~\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  1  0  0  0  0  0  0  0  0\r\n0  0  0  2  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n稀疏矩阵为~~~\r\n11   11   2\r\n1   2   1\r\n2   3   2\r\n恢复的原始矩阵为~~~\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  1  0  0  0  0  0  0  0  0\r\n0  0  0  2  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n0  0  0  0  0  0  0  0  0  0  0\r\n```','2019-10-07 18:06:28','原始数组和稀疏数组的转化','http://pic.51yuansu.com/pic3/cover/01/21/15/59059b1620f8a_610.jpg','原创','','','','数据结构之稀疏数组','2019-10-08 16:58:27',21,1,3),(16,NULL,NULL,'## 队列定义\r\n```java\r\npublic class ArrayQueueDemo {\r\n    class ArrayQueue{\r\n        private int maxSize;//队列最大容量\r\n        private int front;//队头\r\n        private int real;//队尾\r\n        private int[] arr;//存放数据\r\n        //初始化队列\r\n        public ArrayQueue(int maxSize){\r\n            this.maxSize=maxSize;\r\n            front=-1;\r\n            real=-1;\r\n            arr=new int[maxSize];\r\n        }\r\n        //判断队空\r\n        public boolean isEmpty(){\r\n            return front==real;\r\n        }\r\n        //判断队满\r\n        public boolean isFull(){\r\n            return real==maxSize-1;\r\n        }\r\n        //入队\r\n        public void addQueue(int n){\r\n            if (isFull()){\r\n                System.out.println(\"队列已满！\");\r\n                return;\r\n            }\r\n            real++;\r\n            arr[real]=n;\r\n        }\r\n        //出队\r\n        public int getQueue(){\r\n            if (isEmpty()){\r\n                throw new RuntimeException(\"队列为空！\");\r\n            }\r\n            front++;\r\n            return arr[front];\r\n        }\r\n        //显示队列所有数据\r\n        public void show(){\r\n            if (isEmpty()){\r\n                System.out.println(\"队列为空！\");\r\n                return;\r\n            }\r\n            for (int i = front+1; i < arr.length; i++) {\r\n                System.out.println(arr[i]+\" \");\r\n            }\r\n        }\r\n        //显示队列头数据\r\n        public int showHead(){\r\n            if (isEmpty()){\r\n                throw new RuntimeException(\"队列为空！\");\r\n            }\r\n            return arr[front+1];\r\n        }\r\n    }\r\n}\r\n```\r\n缺点：数组没有达到复用的效果\r\n## 改进环形队列\r\n\r\n### 改进思路\r\n\r\n1.front 指向队列第一个元素，real指向队列对列最后一个元素的后一个位置。空出最后一个位置做为约定。\r\n\r\n2.当队列满时:  (real+1)%maxSize==front\r\n\r\n3.当队列空时: real==front\r\n\r\n4.队列中的数据个数: (real+maxSize-front)%maxSize\r\n\r\n### 改进代码\r\n\r\n```java\r\npublic class AnnulusQueueDemo {\r\n    class ArrayQueue{\r\n        private int maxSize;//队列最大容量\r\n        private int front;//队头\r\n        private int real;//队尾\r\n        private int[] arr;//存放数据\r\n        //初始化队列\r\n        public ArrayQueue(int maxSize){\r\n            this.maxSize=maxSize;\r\n            front=0;\r\n            real=0;\r\n            arr=new int[maxSize];\r\n        }\r\n        //判断队空\r\n        public boolean isEmpty(){\r\n            return front==real;\r\n        }\r\n        //判断队满\r\n        public boolean isFull(){\r\n            return (real+1)%maxSize==front;\r\n        }\r\n        //入队\r\n        public void addQueue(int n){\r\n            if (isFull()){\r\n                System.out.println(\"队列已满！\");\r\n                return;\r\n            }\r\n            arr[real]=n;\r\n            real=(real+1)%maxSize;\r\n        }\r\n        //出队\r\n        public int getQueue(){\r\n            if (isEmpty()){\r\n                throw new RuntimeException(\"队列为空！\");\r\n            }\r\n            int i = arr[front];\r\n            front=(front+1)%maxSize;\r\n            return i;\r\n        }\r\n        //显示队列所有数据\r\n        public void show(){\r\n            if (isEmpty()){\r\n                System.out.println(\"队列为空！\");\r\n                return;\r\n            }\r\n            for (int i = front; i < (real+maxSize-front)%maxSize; front=(front+1)%maxSize) {\r\n                System.out.println(arr[i]+\" \");\r\n            }\r\n        }\r\n        //显示队列头数据\r\n        public int showHead(){\r\n            if (isEmpty()){\r\n                throw new RuntimeException(\"队列为空！\");\r\n            }\r\n            return arr[front];\r\n        }\r\n    }\r\n}\r\n```\r\n','2019-10-08 17:01:46','数组模拟队列，环形队列','https://media.gettyimages.com/photos/flat-lay-photo-of-a-creative-freelancer-woman-workspace-desk-picture-id619253894?b=1&k=6&m=619253894&s=612x612&w=0&h=-uqBzMjNJ2eVOn7ofvrm-TppHqkywNeLz1IbyUd350c=','原创','','','','数据结构之队列','2019-10-08 18:03:31',23,1,3),(17,NULL,NULL,'## 1.单链表\r\n\r\n### 1.结点类\r\n\r\n```java\r\nclass HeroNode{\r\n    public int no;\r\n    public String name;\r\n    public String nickName;\r\n    public HeroNode next;//指向下一个结点\r\n\r\n    public HeroNode(int no,String name,String nickName){\r\n        this.name=name;\r\n        this.nickName=nickName;\r\n        this.no=no;\r\n        this.next=null;\r\n    }\r\n\r\n    public HeroNode() {\r\n        this.next=null;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"HeroNode{\" +\r\n                \"no=\" + no +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", nickName=\'\" + nickName + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n### 2.链表类\r\n\r\n```java\r\nclass SingleLinkList{\r\n\r\n    private static final HeroNode head=new HeroNode();\r\n\r\n    //添加数据\r\n    public void add(HeroNode node){\r\n        //添加一个遍历指针 temp\r\n        HeroNode temp=head;\r\n        while (temp.next!=null){\r\n            temp=temp.next;\r\n        }\r\n        temp.next=node;\r\n    }\r\n    //排序添加数据\r\n    public void sortAdd(HeroNode node){\r\n        HeroNode temp=head;\r\n        boolean flag=false;//表示序号不相同\r\n        while (temp.next!=null){\r\n            if (temp.next.no>node.no){\r\n                node.next=temp.next;\r\n                temp.next=node;\r\n                break;\r\n            }else if (temp.next.no<node.no){\r\n                temp=temp.next;\r\n            }else{\r\n                flag=true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag){\r\n            System.out.println(\"序号已存在！\");\r\n        }\r\n        if (temp.next==null){//遍历结束，序号最大，插到最后\r\n            temp.next=node;\r\n        }\r\n    }\r\n    //显示链表数据\r\n    public void show(){\r\n        HeroNode temp=head.next;\r\n        if (head.next==null){\r\n            System.out.println(\"链表为空！\");\r\n        }\r\n        while (temp!=null){\r\n            System.out.println(temp);\r\n            temp=temp.next;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.测试主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        HeroNode heroNode=new HeroNode(1,\"aaa\",\"a\");\r\n        HeroNode heroNode2=new HeroNode(2,\"bbb\",\"bbb\");\r\n        HeroNode heroNode3=new HeroNode(3,\"ccc\",\"c\");\r\n\r\n        SingleLinkList singleLinkList = new SingleLinkList();\r\n//      singleLinkList.add(heroNode);\r\n//      singleLinkList.add(heroNode2);\r\n//      singleLinkList.add(heroNode3);\r\n        singleLinkList.sortAdd(heroNode3);\r\n        singleLinkList.sortAdd(heroNode);\r\n        singleLinkList.sortAdd(heroNode2);\r\n\r\n        singleLinkList.show();\r\n    }\r\n```\r\n\r\n### 4.输出结果\r\n\r\n```\r\nHeroNode{no=1, name=\'aaa\', nickName=\'a\'}\r\nHeroNode{no=2, name=\'bbb\', nickName=\'bbb\'}\r\nHeroNode{no=3, name=\'ccc\', nickName=\'c\'}\r\n```\r\n## 2.双向链表\r\n\r\n### 1.结点类\r\n\r\n```java\r\nclass HeroNode2{\r\n    public int no;\r\n    public String name;\r\n    public String nickName;\r\n    public HeroNode2 next;\r\n    public HeroNode2 pre;\r\n\r\n    public HeroNode2(int no,String name,String nickName){\r\n        this.name=name;\r\n        this.nickName=nickName;\r\n        this.no=no;\r\n        this.next=null;\r\n        this.pre=null;\r\n    }\r\n\r\n    public HeroNode2() {\r\n        this.next=null;\r\n        this.pre=null;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"HeroNode{\" +\r\n                \"no=\" + no +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", nickName=\'\" + nickName + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n### 2.链表类\r\n\r\n```java\r\nclass DoubleLinkedList{\r\n\r\n    private HeroNode2 head= new HeroNode2();\r\n\r\n    //遍历链表\r\n    public void show(){\r\n        HeroNode2 temp = head.next;\r\n        if (temp==null){\r\n            System.out.println(\"链表为空！\");\r\n        }else{\r\n            while (temp!=null){\r\n                System.out.println(temp);\r\n                temp=temp.next;\r\n            }\r\n        }\r\n    }\r\n    //添加\r\n    public void add(HeroNode2 node){\r\n        //添加一个遍历指针 temp\r\n        HeroNode2 temp=head;\r\n        while (temp.next!=null){\r\n            temp=temp.next;\r\n        }\r\n        temp.next=node;\r\n        node.pre=temp;\r\n    }\r\n    //修改\r\n    public void update(HeroNode2 node){\r\n        HeroNode2 temp = head.next;\r\n        while (temp!=null){\r\n            if (temp.no==node.no){\r\n                temp.name=node.name;\r\n                temp.nickName=node.nickName;\r\n                break;\r\n            }\r\n            temp=temp.next;\r\n        }\r\n        if (temp==null){\r\n            System.out.println(\"没找到该编号！\");\r\n        }\r\n    }\r\n    //删除\r\n    public void del(int no){\r\n        HeroNode2 temp = head.next;\r\n        while (temp!=null){\r\n            if (temp.no==no){\r\n                temp.pre.next=temp.next;\r\n                if (temp.next!=null){//若删除的不是最后一个结点\r\n                    temp.next.pre=temp.pre;\r\n                }\r\n                break;\r\n            }\r\n            temp=temp.next;\r\n        }\r\n        if (temp==null){\r\n            System.out.println(\"没有找到该编号！\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        HeroNode2 heroNode=new HeroNode2(1,\"aaa\",\"a\");\r\n        HeroNode2 heroNode2=new HeroNode2(2,\"bbb\",\"bbb\");\r\n        HeroNode2 heroNode3=new HeroNode2(3,\"ccc\",\"c\");\r\n\r\n        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();\r\n        doubleLinkedList.add(heroNode);\r\n        doubleLinkedList.add(heroNode2);\r\n        doubleLinkedList.add(heroNode3);\r\n\r\n        doubleLinkedList.show();\r\n\r\n        System.out.println(\"删除后~~\");\r\n        doubleLinkedList.del(3);\r\n        doubleLinkedList.show();\r\n    }\r\n```\r\n\r\n### 4.输出结果\r\n\r\n```\r\nHeroNode{no=1, name=\'aaa\', nickName=\'a\'}\r\nHeroNode{no=2, name=\'bbb\', nickName=\'bbb\'}\r\nHeroNode{no=3, name=\'ccc\', nickName=\'c\'}\r\n删除后~~\r\nHeroNode{no=1, name=\'aaa\', nickName=\'a\'}\r\nHeroNode{no=2, name=\'bbb\', nickName=\'bbb\'}\r\n```\r\n\r\n## 3.单向环形链表解决约瑟夫问题\r\n\r\n### 1.结点类\r\n\r\n```java\r\nclass Node{\r\n    public int no;\r\n    public Node next;\r\n\r\n    public Node(int no) {\r\n        this.no = no;\r\n    }\r\n\r\n    public Node() {\r\n    }\r\n}\r\n```\r\n\r\n### 2.链表类\r\n\r\n```java\r\nclass AnnulusSingleLinkedList{\r\n\r\n    private Node first;\r\n\r\n    //插入nums个数\r\n    public void add(int nums){\r\n        if (nums<1){\r\n            System.out.println(\"输入错误！\");\r\n            return;\r\n        }\r\n        Node cruBoy = null;//辅助指针\r\n        for (int i = 0; i < nums; i++) {\r\n            Node boy = new Node(i+1);\r\n            if (i==0){//第一个特别处理\r\n                boy.next=boy;\r\n                first=boy;\r\n                cruBoy=first;\r\n            }else{\r\n                cruBoy.next=boy;\r\n                boy.next=first;\r\n                cruBoy=boy;\r\n            }\r\n        }\r\n    }\r\n    //显示\r\n    public void show(){\r\n        Node temp = first;\r\n        if (temp==null){\r\n            System.out.println(\"链表无数据！\");\r\n            return;\r\n        }\r\n        while (true){\r\n            if (temp.next==first){\r\n                System.out.println(\"编号：\"+temp.no);\r\n                break;\r\n            }else{\r\n                System.out.println(\"编号：\"+temp.no);\r\n                temp=temp.next;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 约瑟夫问题\r\n     * @param startNo 开始的位置\r\n     * @param countNo 每次数几个\r\n     * @param nums 总个数\r\n     */\r\n    public void countBoy(int startNo,int countNo,int nums){\r\n        if (startNo<0||countNo<1||nums<1){\r\n            System.out.println(\"输入参数有误\");\r\n            return;\r\n        }\r\n        add(nums);\r\n        for (int i = 0; i < startNo - 1; i++) {//移动first指针到开始位置\r\n            first=first.next;\r\n        }\r\n        Node temp = first;\r\n        while (temp.next!=first){\r\n            temp=temp.next;//辅助指针，指向first前一个结点，用于删除结点\r\n        }\r\n        while (first.next!=first){//循环链表，直到剩下最后一个\r\n            for (int i = 0; i < countNo - 1; i++) {\r\n                first=first.next;\r\n                temp=temp.next;\r\n            }\r\n            System.out.print(first.no+\" \");\r\n            first=first.next;\r\n            temp.next=first;\r\n        }\r\n        System.out.println(first.no);//输出最后一个\r\n    }\r\n}\r\n```\r\n\r\n### 3.主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\r\n        AnnulusSingleLinkedList annulusSingleLinkedList = new AnnulusSingleLinkedList();\r\n        annulusSingleLinkedList.countBoy(2,4,10);\r\n    }\r\n```\r\n\r\n### 4.输出结果\r\n\r\n```\r\n5 9 3 8 4 1 10 2 7 6\r\n```','2019-10-08 21:50:33','单链表，双向链表，循环链表解决瑟夫问题','https://media.gettyimages.com/photos/flat-lay-photo-of-a-creative-freelancer-woman-workspace-desk-picture-id619253894?b=1&k=6&m=619253894&s=612x612&w=0&h=-uqBzMjNJ2eVOn7ofvrm-TppHqkywNeLz1IbyUd350c=','原创','','','','数据结构之单链表','2019-10-10 21:06:39',22,1,3),(18,NULL,NULL,'### 1.栈类\r\n\r\n```java\r\nclass Stack{\r\n\r\n    public int maxSize;\r\n    public int[] stack;\r\n    public int top=-1;\r\n\r\n    public Stack(int maxSize){\r\n        this.maxSize=maxSize;\r\n        stack=new int[this.maxSize];\r\n    }\r\n    //判断栈满\r\n    public boolean isFull(){\r\n        return top == maxSize-1;\r\n    }\r\n    //判断栈空\r\n    public boolean isEmpty(){\r\n        return top == -1;\r\n    }\r\n    //入栈\r\n    public void push(int value){\r\n        if (isFull()){\r\n            System.out.println(\"栈满！\");\r\n            return;\r\n        }\r\n        top++;\r\n        stack[top]=value;\r\n    }\r\n    //出栈\r\n    public int pop(){\r\n        if (isEmpty()){\r\n            throw new RuntimeException(\"栈空\");\r\n        }\r\n        int i = stack[top];\r\n        top--;\r\n        return i;\r\n    }\r\n}\r\n```\r\n\r\n### 2.jdk内置栈类\r\n\r\n栈是Vector的一个子类，它实现了一个标准的后进先出的栈。\r\n\r\n堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\r\n\r\n```\r\nboolean empty()	测试堆栈是否为空。\r\nObject peek( )	查看堆栈顶部的对象，但不从堆栈中移除它。\r\nObject pop( )	移除堆栈顶部的对象，并作为此函数的值返回该对象。\r\nObject push(Object element) 把项压入堆栈顶部。\r\nint search(Object element)	返回对象在堆栈中的位置，以 1 为基数。\r\n```\r\n### 3.综合计算器\r\n\r\n#### 3.1问题与思路\r\n\r\n使用栈完成计算一个表达式的结果：\r\n\r\n7x2x2-5+1=？\r\n\r\n```\r\n1.通过一个index值遍历表达式\r\n2.如果是数字，直接入栈(考虑多位数字)\r\n3.如果为符号。分如下情况\r\n3.1 如果当前符号栈为空，直接入栈\r\n3.2 如果符号栈不为空。如果当前运算符优先级小于或等于栈中运算符，从运算符栈pop出一个符号，从数栈pop两个数，进行运算，将得到的结果push到数栈，将当前操作符push到运算符栈。如果当前运算符优先级高于栈中运算符，直接入栈。\r\n4.扫描完毕，顺序从数栈和运算符栈pop出相应的数和运算符计算\r\n5.最后数栈剩余的一个数就为运算结果\r\n```\r\n\r\n#### 3.2 栈定义\r\n\r\n```java\r\nclass Stack2 extends Stack{\r\n\r\n    public Stack2(int maxSize) {\r\n        super(maxSize);\r\n    }\r\n    //返回栈顶元素，不弹出\r\n    public int peek(){\r\n        return stack[top];\r\n    }\r\n    //返回运算符的优先级\r\n    public int priority(int oper){\r\n        if (oper==\'+\'||oper==\'-\'){\r\n            return 1;\r\n        }\r\n        if (oper==\'*\'||oper==\'/\'){\r\n            return 2;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    //判断是否为运算符\r\n    public boolean isOper(char val){\r\n        return val==\'+\'||val==\'-\'||val==\'*\'||val==\'/\';\r\n    }\r\n    //计算两个数的运算结果\r\n    public int cal(int num1,int num2,int oper){\r\n        int res=0;\r\n        switch (oper) {\r\n            case \'+\':\r\n                res=num1+num2;\r\n                break;\r\n            case \'-\':\r\n                res=num2-num1;\r\n                break;\r\n            case \'*\':\r\n                res=num1*num2;\r\n                break;\r\n            case \'/\':\r\n                res=num2/num1;\r\n                break;\r\n             default:\r\n                 break;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n#### 3.3 主函数实现\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        //实现字符串的计算\r\n        String expression=\"3*5+100-10\";\r\n        Stack2 numStack = new Stack2(10);\r\n        Stack2 operStack = new Stack2(10);\r\n        int index=0;//用于扫描\r\n        int num1=0;\r\n        int num2=0;\r\n        int res=0;\r\n        int oper=0;\r\n        char ch=\' \';\r\n        String keepNum=\"\";//用于拼接多位数字\r\n        while (true){\r\n            ch=expression.substring(index,index+1).charAt(0);\r\n            if (operStack.isOper(ch)){//如果为符号\r\n                if (operStack.isEmpty()){//符号栈空\r\n                    operStack.push(ch);\r\n                }else{//符号栈不空\r\n                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){//判断符号优先级\r\n                        //优先级高的先算\r\n                        num1=numStack.pop();\r\n                        num2=numStack.pop();\r\n                        oper=operStack.pop();\r\n                        res=numStack.cal(num1,num2,oper);//计算\r\n                        numStack.push(res);//计算结果入栈\r\n                        operStack.push(ch);//符号入栈\r\n                    }else{//优先级比栈中高，直接入栈\r\n                        operStack.push(ch);\r\n                    }\r\n                }\r\n            }else {//如果为数字\r\n                keepNum+=ch;\r\n               // numStack.push(ch-48);//ASCII编码 数字1 与 字符1 相差48\r\n                for (int i = index; i <expression.length()-1 ; i++) {//判断是否为多位数字\r\n                    ch=expression.substring(i+1,i+2).charAt(0);\r\n                    if (operStack.isOper(ch)){\r\n                        break;\r\n                    }else{//若后一位是数字\r\n                        keepNum+=ch;\r\n                        index++;//注意后移index\r\n                    }\r\n                }\r\n                numStack.push(Integer.parseInt(keepNum));\r\n                keepNum=\"\";//重置\r\n            }\r\n            //判断是否扫描到最后一位\r\n            index++;\r\n            if (index>=expression.length()-1){\r\n                break;\r\n            }\r\n        }\r\n        while (!operStack.isEmpty()){//当表达式扫描完毕\r\n            num1=numStack.pop();\r\n            num2=numStack.pop();\r\n            oper=operStack.pop();\r\n            res=numStack.cal(num1,num2,oper);\r\n            numStack.push(res);\r\n        }\r\n        System.out.println(expression+\"=\"+numStack.pop());\r\n    }\r\n```\r\n\r\n#### 3.4 运行结果\r\n\r\n```\r\n3*5+100-10=105\r\n```\r\n### 4.逆波兰计算器\r\n\r\n#### 1.思路分析\r\n\r\n```\r\n从左到右扫描后缀表达式\r\n1.如果为数字，直接入栈。\r\n2.如果为运算符，pop出两个，计算结果。运算符若是减法(除法)，后弹出的为被减数(被除数)。\r\n3.最后栈中剩余数字为运算结果。\r\n```\r\n\r\n#### 2.代码\r\n\r\n```java\r\n//将表达式转为list，方便遍历\r\npublic static List<String>  getListString(String suffixExpression){\r\n    String[] split = suffixExpression.split(\" \");\r\n    ArrayList<String> list = new ArrayList<>();\r\n    list.addAll(Arrays.asList(split));\r\n    return list;\r\n}\r\n//完成对逆波兰表达式的计算\r\npublic static int calculate(String suffixExpression){\r\n    List<String> listString = getListString(suffixExpression);\r\n    Stack<String> stack = new Stack<>();\r\n    for (String str : listString) {\r\n        if (str.matches(\"\\\\d+\")) {//匹配到数\r\n            stack.push(str);\r\n        }else {//匹配到运算符\r\n            int num2 = Integer.parseInt(stack.pop());//先弹出\r\n            int num1 = Integer.parseInt(stack.pop());//后弹出\r\n            int res=0;\r\n            switch (str){\r\n                case \"+\":\r\n                    res=num1+num2;\r\n                    break;\r\n                case \"-\":\r\n                    res=num1-num2;//后弹出-先弹出\r\n                    break;\r\n                case \"*\":\r\n                    res=num1*num2;\r\n                    break;\r\n                case \"/\":\r\n                    res=num1/num2;//后弹出/先弹出\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            stack.push(\"\"+res);//stack泛型为String\r\n        }\r\n    }\r\n    return Integer.parseInt(stack.pop());\r\n}\r\n```\r\n\r\n#### 3.主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    String suffixExpression=\"4 5 * 8 - 60 + 8 2 / +\";\r\n    int calculate = calculate(suffixExpression);\r\n    System.out.println(calculate);\r\n}\r\n```\r\n\r\n#### 4.运行结果\r\n\r\n```\r\n76\r\n```\r\n## 5.中缀表达式转后缀表达式\r\n\r\n中缀表达式转后缀表达式并完成逆波兰计算器\r\n\r\n### 1.思路分析\r\n\r\n```\r\n1.初始化两个栈:运算符栈s1和存储结果栈s2\r\n2.从左至右扫描中缀表达式\r\n3.遇到数，直接push到s2\r\n4.遇到运算符，比较其与s1栈顶运算符的优先级\r\n4.1 如果s1为空，或栈顶运算符为（，则直接push到s1\r\n4.2 否则，如果优先级比栈顶元素高，直接push到s1\r\n4.3 否则，将s1栈顶的运算符pop，并push到s2，并转到4.1再次比较\r\n5.遇到括号时\r\n5.1 如果为（ ，直接push到s1\r\n5.2 如果为 ），则依次pop出s1栈顶的运算符，并push到s2，直到遇到（，此时将一堆括号丢弃\r\n6.重复2-5，直到表达式的最右边\r\n7.将s1中剩余的运算符依次pop并push到s2\r\n8.依次弹出s2中的元素，结果的逆序即为中缀表达式对应的后缀表达式\r\n```\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n//将中缀表达式转为list，方便遍历\r\npublic static List<String> toInfixExpressionList(String s){\r\n    ArrayList<String> ls = new ArrayList<>();\r\n    int index=0;\r\n    StringBuilder str;//拼接多位数\r\n    do{\r\n        if (s.charAt(index)<48 || s.charAt(index)>57){//如果不是数字\r\n            ls.add(\"\"+s.charAt(index));\r\n            index++;\r\n        }else{//是数字\r\n            str = new StringBuilder();\r\n            while (index<s.length()&&s.charAt(index)>=48&&s.charAt(index)<=57){\r\n                str.append(s.charAt(index++));\r\n            }\r\n            ls.add(str.toString());\r\n        }\r\n    }while (index<s.length());\r\n    return ls;\r\n}\r\n```\r\n\r\n```java\r\n//实现中缀表达式转后缀表达式\r\npublic static List<String> parses(List<String> stringList){\r\n    Stack<String> s1 = new Stack<>();//运算符栈\r\n    //Stack<String> s2 = new Stack<>();//结果栈 s2没有出栈，用list代替\r\n    List<String> s2=new ArrayList<>();\r\n    for (String ch : stringList) {\r\n        int c=ch.charAt(0);\r\n        if (ch.matches(\"\\\\d+\")){//若为数字\r\n            s2.add(ch);\r\n        }else if (ch.equals(\"+\") || ch.equals(\"-\") || ch.equals(\"*\") || ch.equals(\"/\")){//若为运算符\r\n            do {\r\n                if (s1.isEmpty()|| s1.peek().equals(\"(\")){//s1为空或栈顶为（\r\n                    s1.push(ch);\r\n                    break;\r\n                }else if (priority(c)>priority(s1.peek().charAt(0))){//优先级大于栈顶元素\r\n                    s1.push(ch);\r\n                    break;\r\n                }else{//优先级小于等于\r\n                    s2.add(s1.pop());\r\n                }\r\n            }while (true);\r\n        }else{// 如果为（ 或）\r\n            if (ch.equals(\"(\")){\r\n                s1.push(ch);\r\n            }else{\r\n                while (!s1.peek().equals(\"(\")){//直到扫描到（ 为止\r\n                    s2.add(s1.pop());\r\n                }\r\n                s1.pop();//将（ 弹出，消除小括号\r\n            }\r\n        }\r\n    }\r\n    while (!s1.isEmpty()){//将s1剩余运算符加入s2中\r\n        s2.add(s1.pop());\r\n    }\r\n    return s2;\r\n}\r\n```\r\n\r\n```java\r\n//完成对逆波兰表达式的计算\r\npublic static int calculate(List<String> listString){\r\n    Stack<String> stack = new Stack<>();\r\n    for (String str : listString) {\r\n        if (str.matches(\"\\\\d+\")) {//匹配到数\r\n                stack.push(str);\r\n        }else {//匹配到运算符\r\n            int num2 = Integer.parseInt(stack.pop());\r\n            int num1 = Integer.parseInt(stack.pop());\r\n            int res=0;\r\n            switch (str){\r\n                case \"+\":\r\n                    res=num1+num2;\r\n                    break;\r\n                case \"-\":\r\n                    res=num1-num2;\r\n                    break;\r\n                case \"*\":\r\n                    res=num1*num2;\r\n                    break;\r\n                case \"/\":\r\n                    res=num1/num2;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            stack.push(\"\"+res);\r\n        }\r\n    }\r\n    return Integer.parseInt(stack.pop());\r\n}\r\npublic static int jisuan(String str){\r\n    List<String> stringList = toInfixExpressionList(str);//将中缀表达式转为list，方便遍历\r\n    List<String> parses = parses(stringList);//将中缀表达式转为后缀表达式\r\n    return calculate(parses);//计算\r\n}\r\n```\r\n\r\n### 3.主函数\r\n\r\n```java\r\n    public static void main(String[] args) {\r\n        String expression=\"(10+2)*(1+2)\";\r\n        System.out.println(jisuan(expression));\r\n    }\r\n```\r\n\r\n### 4.输出结果\r\n\r\n```\r\n36\r\n```','2019-10-10 21:11:19','栈的实现，jdk内置栈，实现综合计算器，中缀表达式转后缀表达式，逆波兰计算器','https://images.freeimages.com/images/premium/small-comps/1406/14069496-background-series-painting-wall.jpg','原创','','','','数据结构之栈','2019-10-13 19:04:34',26,1,3),(19,NULL,NULL,'## 1.迷宫回溯\r\n\r\n### 1.思路分析\r\n\r\n```\r\n我们可沿着入口逐一方向进行试探，若有通则继续前进，全不通，回溯法则回溯，递归法则到达递归终止条件。\r\n0：表示没走过\r\n1：表示墙\r\n2：表示通路\r\n3：表示回溯的路径(不通)\r\n```\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n/**\r\n     * 判断该位置是否可行\r\n     * @param map 数组\r\n     * @param i 横坐标\r\n     * @param j 纵坐标\r\n     * @return 是否可行\r\n     */\r\npublic static boolean setWay(int[][] map,int i,int j){\r\n    if (map[6][5]==2){\r\n        return true;\r\n    }else{\r\n        if (map[i][j]==0){//没走过\r\n            map[i][j]=2;//假定该路可行\r\n            if (setWay(map,i+1,j)){//向下走\r\n                return true;\r\n            }else if (setWay(map,i,j+1)){//向右走\r\n                return true;\r\n            }else if (setWay(map,i-1,j)){//向左走\r\n                return true;\r\n            }else if (setWay(map,i,j-1)){//向上走\r\n                return true;\r\n            }else{\r\n                map[i][j]=3;//走不通\r\n                return false;\r\n            }\r\n        }else {//有墙或不通或已走过\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3. 主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    //定义一个迷宫数组,0表示没走过，1 表示墙 ， 2表示 走过， 3表示走不通\r\n    int[][] map=new int[8][7];\r\n    //设置墙\r\n    for (int i = 0; i < 7; i++) {//第一行和最后一行\r\n        map[0][i]=1;\r\n        map[7][i]=1;\r\n    }\r\n    for (int i = 0; i < 8; i++) {//第一列和最后一列\r\n        map[i][0]=1;\r\n        map[i][6]=1;\r\n    }\r\n    for (int i = 0; i <5 ; i++) {\r\n        map[2][i]=1;\r\n        map[4][i+2]=1;\r\n    }\r\n    //输出矩阵\r\n    for (int i = 0; i < 8; i++) {\r\n        for (int j = 0; j < 7; j++) {\r\n            System.out.print(map[i][j]+\"  \");\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n    setWay(map,1,1);\r\n    System.out.println(\"~~~\");\r\n    for (int i = 0; i < 8; i++) {\r\n        for (int j = 0; j < 7; j++) {\r\n            System.out.print(map[i][j]+\"  \");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n```\r\n\r\n### 4.运行结果\r\n\r\n```\r\n1  1  1  1  1  1  1  \r\n1  0  0  0  0  0  1  \r\n1  1  1  1  1  0  1  \r\n1  0  0  0  0  0  1  \r\n1  0  1  1  1  1  1  \r\n1  0  0  0  0  0  1  \r\n1  0  0  0  0  0  1  \r\n1  1  1  1  1  1  1  \r\n~~~\r\n1  1  1  1  1  1  1  \r\n1  2  2  2  2  2  1  \r\n1  1  1  1  1  2  1  \r\n1  2  2  2  2  2  1  \r\n1  2  1  1  1  1  1  \r\n1  2  0  0  0  0  1  \r\n1  2  2  2  2  2  1  \r\n1  1  1  1  1  1  1  \r\n```\r\n\r\n## 2.八皇后问题\r\n\r\n### 1.问题介绍\r\n\r\n八皇后问题是一个以[国际象棋](https://zh.wikipedia.org/wiki/国际象棋)为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个[皇后](https://zh.wikipedia.org/wiki/后_(国际象棋))，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。\r\n### 2.代码实现\r\n\r\n```java\r\n//放置第n个皇后\r\npublic void check(int n){\r\n    if (n==max){//已经放好8个（从0开始）\r\n        print();\r\n        return;\r\n    }\r\n    for (int i = 0; i < max; i++) {\r\n        array[n]=i;\r\n        if (judge(n)){//不冲突\r\n            check(n+1);\r\n        }\r\n    }\r\n}\r\n//输出array\r\npublic void print(){\r\n    for (int i = 0; i < max; i++) {\r\n        System.out.print(array[i]+\" \");\r\n    }\r\n    System.out.println();\r\n    count++;\r\n}\r\n//判断放入的第n个皇后是否与其他冲突\r\npublic boolean judge(int n){\r\n    for (int i = 0; i < n; i++) {\r\n        if (array[n]==array[i] || Math.abs(n-i) == Math.abs(array[n]-array[i])){//如果冲突\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n### 3.主函数\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    Queue8 queue8=new Queue8();\r\n    queue8.check(0);//放第一个\r\n    System.out.println(\"一共\"+count);\r\n}\r\n```\r\n\r\n### 4.运行结果\r\n\r\n```\r\n0 4 7 5 2 6 1 3 \r\n0 5 7 2 6 3 1 4 \r\n0 6 3 5 7 1 4 2 \r\n0 6 4 7 1 3 5 2 \r\n1 3 5 7 2 0 6 4 \r\n...............\r\n省略\r\n...............\r\n7 1 3 0 6 4 2 5 \r\n7 1 4 2 0 6 3 5 \r\n7 2 0 5 1 4 6 3 \r\n7 3 0 2 5 1 6 4 \r\n一共92\r\n```','2019-10-13 19:03:45','迷宫回溯，八皇后问题','https://images.freeimages.com/images/premium/small-comps/1531/1531786-grunge-material.jpg','原创','','','','数据结构与算法之递归','2019-10-13 20:15:04',19,1,3),(20,NULL,NULL,'# 1.基础指令\r\n\r\n## 1.ls指令\r\n\r\n#ls  列出当前工作目录下的所有文件/文件夹的名称\r\n\r\nls -l   以列表形式列出\r\n\r\n#ls -lh 以列表的形式并且在显示文档大小的时候以可读性较高的形式显示\r\n\r\n颜色说明：蓝色为文件夹，黑色为文件，绿色的拥有全部权限\r\n\r\n## 2.pwd指令\r\n\r\n#pwd 打印当前工作路径\r\n\r\n## 3.cd指令\r\n\r\n#cd 路径   进入路径\r\n\r\n## 4.mkdir指令\r\n\r\n#mkdir 路径  创建文件夹，只能创建一层目录\r\n\r\n#mkdir -p 路径  创建文件夹，可创建多级目录\r\n\r\n#mkdir 路径1 路径2 路径3\r\n\r\n## 5.touch指令\r\n\r\n#touch 路径 创建文件\r\n\r\n#touch 路径1 路径2\r\n\r\n## 6.cp指令\r\n\r\n#cp 被复制的文档  文档保存路径\r\n\r\n#cp -r  复制文件夹     -r  表示递归，多级\r\n\r\n## 7.mv指令\r\n\r\n#mv 需要移动的文档路径  保存的路径\r\n\r\n可用作重命名  原地移动\r\n\r\n## 8.rm指令\r\n\r\n#rm 路径  删除\r\n\r\n#rm -f 路径    强制删除，不提示\r\n\r\n#rm -rf 路径    删除目录\r\n\r\n## 9.vim指令\r\n\r\n#vim 路径 进入文件\r\n\r\n退出   输入 **： q**  回车\r\n\r\n更改   **Insert **键\r\n\r\n## 10.输出重定向\r\n\r\n一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析统计，则这时候需要使用到的输出重定向技术。\r\n\r\n\\>：覆盖输出，会覆盖掉原先的文件内容\r\n\r\n\\>>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加\r\n\r\n## 11.cat指令\r\n\r\n#cat 文件路径    直接打开一个文件，不编辑\r\n\r\n#cat 待合并路径1 待合并路径2 ...    >  合并后文件路径 \r\n\r\n# 2.进阶指令\r\n\r\n## 1.df指令\r\n\r\n#df -h   查询磁盘使用情况  看第一行\r\n\r\n## 2.free指令\r\n\r\n#free -m  查看内存           -m   M兆为单位   看第二行   swap虚拟内存\r\n\r\n## 3.head指令\r\n\r\n#head -N 文件             查看一个文件的前N行，默认10\r\n\r\n## 4.tail指令\r\n\r\n#tail -N 文件         查看文件后N行\r\n\r\n#tail -f 文件           监测文件，输出追加的内容,内容不能为手动添加的，一般用于查看日志\r\n\r\n## 5.less\r\n\r\n#less 文件      查看文件，具有辅助功能键  数字+回车：跳到第几行   方向键滚动  回车下一行\r\n\r\n## 6.wc\r\n\r\n#wc -lwc 需要统计的文件路径    \r\n\r\n-l：行数\r\n\r\n-w：单词数\r\n\r\n-c: 字节数\r\n\r\n## 7.date指令\r\n\r\n#data    输出当前时间  \r\n\r\n#data +%F    2019-9-15\r\n\r\n# 3.连接虚拟机\r\n\r\n查看虚拟机端口号指令  ip addr\r\n\r\n关闭linux防火墙  service iptables stop\r\n\r\n安装ssh服务  yum install –y ssh\r\n\r\n开启ssh服务  service sshd start\r\n\r\n解压 tar -zxvf \r\n\r\n# 4.linux安装jdk\r\n\r\n1.上传文件\r\n\r\n2.解压，将解压后的文件移动到 /usr/local/\r\n\r\n`mv jdk1.8.0_141/ /usr/local/`\r\n\r\n3.添加环境变量\r\n\r\n`vim /etc/profile`\r\n\r\n在末尾添加\r\n\r\n```\r\nexport JAVA_HOME=/usr/local/jdk1.8.0_141\r\nexport PATH=$JAVA_HOME/bin:$PATH\r\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\n```\r\n\r\n4.重启服务器\r\n\r\n5.查看是否安装成功\r\n\r\n`java -version`\r\n\r\n\r\n\r\n# 5.linux 安装mysql\r\n\r\n1.安装mysql\r\n\r\n```\r\nwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm\r\nrpm -ivh mysql-community-release-el7-5.noarch.rpm\r\nyum update\r\nyum install mysql-server\r\n```\r\n\r\n2.权限设置\r\n\r\n```\r\nchown mysql:mysql -R /var/lib/mysql\r\n```\r\n\r\n3.初始化 MySQL\r\n\r\n```\r\nmysqld --initialize\r\n```\r\n\r\n4.启动 MySQL\r\n\r\n```\r\nsystemctl start mysqld\r\n```\r\n\r\n5.查看 MySQL 运行状态\r\n\r\n```\r\nsystemctl status mysqld\r\n```\r\n\r\n6.设置密码\r\n\r\n```\r\nmysqladmin -u root password \"new_password\";\r\n```\r\n\r\n\r\n\r\n# 6.部署服务器\r\n\r\n1.上传文件\r\n\r\n2.创建数据库  \r\n\r\n```\r\ncreate database blog charset=\'utf8\';\r\n```\r\n\r\n3.发布项目\r\n\r\n```\r\nnohup java -jar blog.xxxxx > blog_log.txt &\r\n```\r\n\r\nnohup 为后台运行\r\n\r\n# [7.备份数据库](https://www.jianshu.com/p/b77dfd6d998b)\r\n\r\n备份一个数据库\r\n\r\n```\r\nmysqldump -uusername -pmypwd databasename > /root/sql/mysql.sql\r\n```\r\n\r\n备份并压缩\r\n\r\n```\r\nmysqldump -hhostname -uusername -pmypwd databasename ｜ gzip > /path to backup/bakname.sql.gz\r\n```\r\n\r\n还原无压缩数据库\r\n\r\n```\r\nmysql －hhostname -uuser -pmypwd databasename < /path to backup/bakname.sql\r\n```\r\n\r\n还原压缩数据库\r\n\r\n```\r\ngunzip < /path to backup/bakname.sql.gz | mysql -hhostname -uusername -pmypwd databasename\r\n```\r\n\r\n/* ....  / 在大部分语言中都一样是注释。这个之中的语句是不被执行的。\r\n但MYSQL中 为了保持兼容，比如从mysqldump 导出的SQL语句能被其它数据库直接使用，它把一些特有的仅在MYSQL上的语句放在 /! ... */ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中它会执行。\r\n\r\n','2019-10-13 19:21:31','linux基本指令，jdk，mysql安装','https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTq01JZUQ4XiI86S_59vPIod02So2GuOpJL0nkNJ3S0mWrluTA-','原创','','','','linux相关操作','2019-10-13 19:21:31',18,1,3),(21,NULL,NULL,'# 排序\r\n\r\n## 1.冒泡排序\r\n\r\n### 1.思路分析\r\n\r\n1. 比较相邻的元素。 如果第一个比第二个大，就交换他们两个。\r\n\r\n2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数。\r\n\r\n3. 针对所有的元素重复以上的步骤，除了最后一个。\r\n\r\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\npublic static void sort(int[] arr){\r\n    int temp;\r\n    boolean flag=false;//改进，判断某躺遍历是否发生交换，若没交换，遍历结束\r\n    for (int i = 0; i < arr.length-1; i++) {\r\n        flag=false;\r\n        for (int j = 0; j < arr.length-1-i; j++) {\r\n            if (arr[j]>arr[j+1]){\r\n                flag=true;\r\n                temp=arr[j];\r\n                arr[j]=arr[j+1];\r\n                arr[j+1]=temp;\r\n            }\r\n        }\r\n        if (!flag){\r\n            break;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.测试\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    int arr[] = new int[80000];\r\n    for (int i = 0; i < 80000; i++) {\r\n        arr[i] = (int)(Math.random()*8000000);\r\n    }\r\n    Date date1 = new Date();\r\n    SimpleDateFormat simpleFormatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n    String date1Str = simpleFormatter.format(date1);\r\n    System.out.println(\"排序前时间：\"+date1Str);\r\n    sort(arr);\r\n    Date date2 = new Date();\r\n    SimpleDateFormat simpleFormatter1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n    String date2Str = simpleFormatter1.format(date2);\r\n    System.out.println(\"排序后时间：\"+date2Str);\r\n}\r\n```\r\n\r\n### 4.运行结果\r\n\r\n```\r\n排序前时间：2019-10-14 20:25:12\r\n排序后时间：2019-10-14 20:25:25\r\n```\r\n\r\n## 2.选择排序\r\n\r\n### 1.思路分析\r\n\r\n**选择排序**（Selection sort）是一种简单直观的[排序算法](https://zh.wikipedia.org/wiki/排序算法)。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n public static void sort(int[] arr){\r\n     int min=arr[0];\r\n     int k=0;\r\n     int temp;\r\n     for (int i = 0; i < arr.length - 1; i++) {\r\n         k=i;//假定第一个为最小，k为最小值的下标\r\n         min=arr[i];//min为最小值\r\n         for (int j = i; j < arr.length; j++) {\r\n             if (min>arr[j]){//如果发现还小的\r\n                 min=arr[j];//更新min\r\n                 k=j;//更新下表\r\n             }\r\n         }\r\n         if (k!=i){//如果下表发生变化，交换，确定一个最小值\r\n             temp=arr[i];\r\n             arr[i]=arr[k];\r\n             arr[k]=temp;\r\n         }\r\n     }\r\n }\r\n```\r\n\r\n### 3.测试结果\r\n\r\n```\r\n排序前时间：2019-10-14 20:33:50\r\n排序后时间：2019-10-14 20:33:52\r\n```\r\n\r\n## 3.插入排序\r\n\r\n### 1.思路分析\r\n\r\n**插入排序**（Insertion Sort）是一种简单直观的[排序算法](https://zh.wikipedia.org/wiki/排序算法)。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\r\n\r\n## 2.代码实现\r\n\r\n```java\r\npublic static void sort(int[] arr){\r\n    int k,temp;//temp:待插入的数\r\n    for (int i = 1; i < arr.length; i++) {\r\n        temp=arr[i];\r\n        k=-1;//注意重置，若temp一开始就大于前面的数，会结束循环\r\n        for (int j = i-1; j >=0 ; j--) {//从后向前扫描\r\n            if (temp<arr[j]){//temp小于前面的数，后移\r\n                arr[j+1]=arr[j];//后移\r\n                k=j;//记录插入位置\r\n            }else{//temp大于等于前面的数，直接退出循环，进行下一个数的插入\r\n                break;\r\n            }\r\n        }\r\n        if (k!=-1){//若移动过\r\n            arr[k]=temp;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.测试结果\r\n\r\n```\r\n排序前时间：2019-10-15 17:27:58.334\r\n排序后时间：2019-10-15 17:27:59.25\r\n```\r\n## 4.希尔排序\r\n\r\n### 1.思路分析\r\n\r\n**希尔排序**(Shell\'s Sort)是[插入排序](https://baike.baidu.com/item/插入排序)的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\npublic static void sort(int[] arr){\r\n        int temp;//交换使用\r\n        int length=arr.length;\r\n        for (int step = length/2; step>=1; step/=2) {//记录步长\r\n            for (int i = step; i <length; i++) {//从前向后扫描,此时i为第一组的第二个元素\r\n                temp=arr[i];\r\n                int j=i-step;\r\n                while(j>=0&&arr[j]>temp){\r\n                    arr[j+step]=arr[j];\r\n                    j-=step;\r\n                }\r\n                arr[j+step]=temp;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n### 3.测试结果(800000)\r\n\r\n```\r\n排序前时间：2019-11-01 19:13:44.414\r\n排序后时间：2019-11-01 19:13:44.753\r\n```\r\n\r\n## 5.快速排序\r\n\r\n### 1.思路分析\r\n\r\n1. 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），\r\n2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，\r\n3. 递归排序子序列：[递归](https://zh.wikipedia.org/wiki/递归)地将小于基准值元素的子序列和大于基准值元素的子序列排序。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\nprivate static void sort(int[] arr, int low, int high) {\r\n    if (low < high) {\r\n        // 找寻基准数据的正确索引\r\n        int index = getIndex(arr, low, high);\r\n        // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序\r\n        sort(arr, low, index - 1);\r\n        sort(arr, index + 1, high);\r\n    }\r\n}\r\nprivate static int getIndex(int[] arr, int low, int high) {\r\n    // 基准数据\r\n    int tmp = arr[low];\r\n    while (low < high) {\r\n        // 当队尾的元素大于等于基准数据时,向前挪动high指针\r\n        while (low < high && arr[high] >= tmp) {\r\n            high--;\r\n        }\r\n        // 如果队尾元素小于tmp了,需要将其赋值给low\r\n        arr[low] = arr[high];\r\n        // 当队首元素小于等于tmp时,向前挪动low指针\r\n        while (low < high && arr[low] <= tmp) {\r\n            low++;\r\n        }\r\n        // 当队首元素大于tmp时,需要将其赋值给high\r\n        arr[high] = arr[low];\r\n    }\r\n    // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置\r\n    // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]\r\n    arr[low] = tmp;\r\n    return low; // 返回tmp的正确位置\r\n}\r\n```\r\n\r\n### 3.测试结果\r\n\r\n```\r\n排序前时间：2019-11-02 10:40:20\r\n排序后时间：2019-11-02 10:40:20\r\n```\r\n\r\n## 6.归并排序\r\n\r\n### 1.思路分析\r\n\r\n- 分割：递归地把当前序列平均分割成两半。\r\n- 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n/**\r\n     *合并\r\n     * @param arr 代排序的数组\r\n     * @param left 数组头\r\n     * @param mid\r\n     * @param right\r\n     * @param temp 额外的数组\r\n     */\r\npublic static void merge(int[] arr,int left,int mid,int right,int[] temp){\r\n    int i=left;\r\n    int j=mid+1;\r\n    int t=0;\r\n    while (i<=mid&&j<=right){\r\n        if (arr[i]<arr[j]){\r\n            temp[t++]=arr[i++];\r\n        }else {\r\n            temp[t++]=arr[j++];\r\n        }\r\n    }\r\n    while (i<=mid){\r\n        temp[t++]=arr[i++];\r\n    }\r\n    while (j<=right){\r\n        temp[t++]=arr[j++];\r\n    }\r\n    t=0;\r\n    int tempLeft=left;\r\n    while (tempLeft<=right){//  <=\r\n        arr[tempLeft++]=temp[t++];\r\n    }\r\n}\r\n//分解\r\npublic static void sort(int[] arr,int left,int right,int[] temp){\r\n    if (left<right){//分解终止条件\r\n        int mid=(left+right)/2;//分解的关键\r\n        sort(arr,left,mid,temp);//递归分解枢轴左边\r\n        sort(arr,mid+1,right,temp);//递归分解枢轴右边\r\n        merge(arr,left,mid,right,temp);//合并\r\n    }\r\n}\r\n```\r\n\r\n### 3.测试结果\r\n\r\n```\r\n排序前时间：2019-11-02 16:05:14\r\n排序后时间：2019-11-02 16:05:14\r\n```\r\n\r\n## 7.基数排序\r\n\r\n### 1.思路分析\r\n\r\n将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。空间换取时间。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\npublic static void sort(int[] arr){\r\n    int[][] bucket = new int[10][arr.length];//定义桶\r\n    int[] bucketElementCounts = new int[10];//存放桶中元素个数的数组\r\n    //求出最大数的位数\r\n    int max=arr[0];\r\n    for (int i =1; i < arr.length; i++) {\r\n        if (arr[i]>max){\r\n            max=arr[i];\r\n        }\r\n    }\r\n    int maxLength = (max+\"\").length();\r\n    for (int i = 0; i < maxLength; i++) {//最高位数\r\n        for (int j = 0; j < arr.length; j++) {//循环每个数\r\n            int digitOfElement;//记录取余后的数\r\n            if (i==0){\r\n                digitOfElement = arr[j]%10;\r\n            }else{\r\n                digitOfElement = (arr[j]/(i*10))%10;\r\n            }\r\n            bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];//放入桶中\r\n            bucketElementCounts[digitOfElement]++;//更新桶中元素个数，一轮过后注意置零\r\n        }\r\n        int index=0;\r\n        for (int j = 0; j < 10; j++) {\r\n            for (int k = 0; k < bucketElementCounts[j]; k++) {\r\n                arr[index++]=bucket[j][k];//复制到arr数组中\r\n            }\r\n            bucketElementCounts[j]=0;//注意置零\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.测试结果\r\n\r\n```\r\n排序前时间：2019-11-02 17:29:22.413\r\n排序后时间：2019-11-02 17:29:22.521\r\n```','2019-10-14 21:21:05','冒泡排序，选择排序，插入排序等7种排序','https://images.freeimages.com/images/premium/small-comps/1141/1141056-painted-stone-wall.jpg','原创','','','','数据结构与算法之排序','2019-12-15 19:53:10',19,1,3),(22,NULL,NULL,'# jvm\r\n\r\n## 1.程序计数器\r\n\r\nPC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。\r\n\r\n- 作用，是记住下一条jvm指令的执行地址\r\n- 特点\r\n  - 线程私有\r\n  - 不会存在内存溢出\r\n\r\n## 2.[虚拟机栈](https://www.cnblogs.com/paddix/p/5309550.html)\r\n\r\n虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值\r\n\r\n- 垃圾回收不涉及栈内存\r\n- 如果方法内部局部变量没有逃离方法的作用范围，他是线程安全的。比如返回局部变量，线程不安全。\r\n- 栈内存溢出\r\n  - 栈帧调用过多（递归死循环）\r\n  - 栈帧过大，不容易出现\r\n- -Xss256k  设置栈大小\r\n- 线程运行诊断\r\n  - top  列出全部进程\r\n  - ps H -eo pid,tid,%cpu | grep 进程id    具体列出进程的全部线程\r\n  - jsttack 进程id  查看线程具体情况\r\n\r\n## 3.本地方法区\r\n\r\n这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容。\r\n\r\n## 4.堆\r\n\r\n堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。\r\n\r\n- 通过 new 关键字，创建对象都会使用堆内存\r\n- 特点\r\n  - 线程共享，堆中对象要考虑线程安全的问题\r\n  - 垃圾回收\r\n- 堆内存溢出\r\n  - -Xmx8m  设置堆空间\r\n\r\n## 5.方法区Matespace(1.8之后)\r\n\r\n![jvm内存模型](https://images2015.cnblogs.com/blog/820406/201603/820406-20160326200119386-756216654.png)\r\n\r\n- 方法区(概念)  元空间(实现)\r\n\r\n- [Java String](https://www.cnblogs.com/paddix/p/5326863.html)\r\n\r\n  \r\n\r\n## 6.直接内存\r\n\r\n## 7.垃圾回收\r\n\r\n[垃圾回收](https://www.jianshu.com/p/5261a62e4d29)\r\n\r\n**1.什么是垃圾回收？**\r\n\r\n​    垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。\r\n\r\n​    注意：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。\r\n\r\n***分析：***\r\n\r\n​    引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。（***引用都有哪些？对垃圾回收又有什么影响？***）\r\n\r\n​    垃圾：无任何对象引用的对象（***怎么通过算法找到这些对象呢？***）。\r\n\r\n​    回收：清理“垃圾”占用的内存空间而非对象本身（**怎么通过算法实现回收呢？**）。\r\n\r\n​    发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中（***堆内存为了配合垃圾回收有什么不同区域划分，各区域有什么不同？***）。\r\n\r\n​    发生时间：程序空闲时间不定时回收（***回收的执行机制是什么？*****是否可以通过显示调用函数的方式来确定的进行回收过程？**）\r\n\r\n​    带着这些问题我们开始进一步的分析。\r\n\r\n**2.Java中的对象引用**\r\n\r\n  （1）强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。\r\n\r\n  （2）软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。\r\n\r\n  （3）弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。\r\n\r\n  （4）虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。\r\n\r\n**3.判断对象是否是垃圾的算法。**\r\n\r\n​      Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）找到所有存活对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。\r\n\r\n**3.1引用计数算法（Reference Counting Collector）**\r\n\r\n​    堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。\r\n\r\n​    优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）。\r\n\r\n​    缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。\r\n\r\n​    早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历（***根搜索算法***）。\r\n\r\n**3.2根搜索算法（Tracing Collector）**\r\n\r\n首先了解一个概念：***根集(Root Set)***\r\n\r\n​    所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。\r\n\r\n​    这种算法的基本思路：\r\n\r\n （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。\r\n\r\n （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。\r\n\r\n （3）重复（2）。\r\n\r\n （4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。\r\n\r\n​    Java和C#中都是采用根搜索算法来判定对象是否存活的。\r\n\r\n**标记可达对象：**\r\n\r\n​    JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图。下图3.0中所展示的JVM中的内存布局可以用来很好地阐释这一概念：\r\n\r\n![](https://upload-images.jianshu.io/upload_images/3789193-db98b5d3a266c24d.png?imageMogr2/auto-orient/strip|imageView2/2/w/584/format/webp)\r\n\r\n 首先，垃圾回收器将某些特殊的对象定义为GC根对象。所谓的GC根对象包括：\r\n\r\n（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；\r\n\r\n（2）方法区中的常量引用的对象；\r\n\r\n（3）方法区中的类静态属性引用的对象；\r\n\r\n（4）本地方法栈中JNI（Native方法）的引用对象。\r\n\r\n（5）活跃线程。\r\n\r\n​    接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。\r\n\r\n​    存活对象在上图中被标记为蓝色。当标记阶段完成了之后，所有的存活对象都已经被标记完了。其它的那些（上图中灰色的那些）也就是GC根对象不可达的对象，也就是说你的应用不会再用到它们了。这些就是垃圾对象，回收器将会在接下来的阶段中清除它们。\r\n\r\n**关于标记阶段有几个关键点是值得注意的：**\r\n\r\n​    （1）开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。\r\n\r\n​    （2）暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。\r\n\r\n​    （3）在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：\r\n\r\n​      1.如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法（可看作析构函数，类似于OC中的dealloc，Swift中的deinit）。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。\r\n\r\n​      2.如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。\r\n\r\n​     （4）实际上GC判断对象是否可达看的是强引用。\r\n\r\n​    当标记阶段完成后，GC开始进入下一阶段，删除不可达对象。','2019-10-25 14:41:04','jvm编程原理，链接优质技术博客','https://images.freeimages.com/images/premium/small-comps/6693/6693200-abstract-artwork.jpg','原创','','','','jvm编程原理','2019-10-25 14:41:04',17,1,3),(23,NULL,NULL,'# 查找\r\n\r\n## 1.二分查找\r\n\r\n### 1.思路分析\r\n\r\n首先，假设表中元素是按升序排列，将表中间位置记录的[关键字](https://baike.baidu.com/item/关键字)与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置[记录](https://baike.baidu.com/item/记录/1837758)将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的[记录](https://baike.baidu.com/item/记录/1837758)，使查找成功，或直到子表不存在为止，此时查找不成功。\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n//返回下标\r\npublic static int search(int[] arr,int left,int right,int value){\r\n    if (left<right){\r\n        int mid = (left+right)/2;\r\n        int midVal = arr[mid];\r\n        if (midVal==value){\r\n            return mid;\r\n        }else if(midVal > value){\r\n            return search(arr,left,mid-1,value);\r\n        }else{\r\n            return search(arr,mid+1,right,value);\r\n        }\r\n    }else{\r\n        return -1;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n//改进：可以查找重复数字，返回一个列表\r\npublic static ArrayList<Integer> search1(int[] arr, int left, int right, int value){\r\n    if (left<right){\r\n        int mid = (left+right)/2;\r\n        int midVal = arr[mid];\r\n        if (midVal==value){//改进部分\r\n            //return mid;\r\n            ArrayList<Integer> list = new ArrayList<>();\r\n            list.add(mid);\r\n            int temp = mid-1;//向左扫描\r\n            while (temp>0 && arr[temp]==arr[mid]){\r\n                list.add(temp);\r\n                temp--;\r\n            }\r\n            temp=mid+1;\r\n            while (temp<arr.length-1 && arr[temp] == arr[mid]){\r\n                list.add(temp);\r\n                temp++;\r\n            }\r\n            return list;\r\n        }else if(midVal > value){\r\n            return search1(arr,left,mid-1,value);\r\n        }else{\r\n            return search1(arr,mid+1,right,value);\r\n        }\r\n    }else{\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n## 2.插值查找\r\n\r\n### 1.思路分析\r\n\r\n插值查找除要求查找表是顺序存储的有序表外，还要求数据元素的关键字在查找表中均匀分布，这样，就可以按比例插值。\r\n\r\nmid = left + (right - left) * (value - arr[left])/(arr[right] - arr[left]);\r\n\r\n## 3.斐波那契查找\r\n\r\n### 1.思路分析\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/8/31/1659058504b95e14?imageslim)\r\n\r\n### 2.代码实现\r\n\r\n```java\r\n//生成一个斐波那契数组\r\npublic static int[] fib(){\r\n    int[] f = new int[10];\r\n    f[0]=1;\r\n    f[1]=1;\r\n    for (int i = 2; i < 10; i++) {\r\n        f[i]=f[i-1]+f[i-2];\r\n    }\r\n    return f;\r\n}\r\n//非递归\r\npublic static int fibSearch(int[] arr,int key){\r\n    int low,high,mid,k;\r\n    low=0;\r\n    k=0;//表示当前指向的斐波那契数组下标\r\n    high=arr.length-1;\r\n    int[] fib = fib();\r\n    while (high>fib[k]-1){//使k指向初始位置\r\n        k++;\r\n    }\r\n    int[] temp = Arrays.copyOf(arr,fib[k]);//复制一个数组，长度为fib[k]，为了使用斐波那契查找\r\n    for (int i = arr.length; i < fib[k]; i++) {\r\n        temp[i]=arr[high];//补全新加的\r\n    }\r\n    while (low < high){\r\n        mid = low + fib[k-1] -1;  //fib[k-1]为左部分，fib[k-1] -1 是为了和第一个数为0与数组对应\r\n        if (temp[mid] == key){//找到\r\n            if (mid < arr.length){//mid不在新加的里面\r\n                return mid;\r\n            }else{\r\n                return high;\r\n            }\r\n        }else if (temp[mid] > key){\r\n            high = mid -1;\r\n            k--;//k-- ，下一步 mid = low +  左部分 fib[k-1]为左部分\r\n        }else{\r\n            low = mid +1;\r\n            k-=2;//k-=2 ，下一步 mid = （mid + 1） + 右部分  fib[k-2]为右部分\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n```\r\n\r\n\r\n\r\n# 哈希表(简单实现)\r\n\r\n## 1.基本概念\r\n\r\n**散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/鍵)（Key）而直接访问在内存存储位置的[数据结构](https://zh.wikipedia.org/wiki/数据结构)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/映射)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/散列函数)，存放记录的数组称做**散列表**。\r\n\r\n## 2.代码实现\r\n\r\nEmp类，一个对象代表一个结点\r\n\r\n```java\r\nclass Emp{\r\n    public int id;\r\n    public String name;\r\n    public Emp next;\r\n    public Emp(int id,String name){\r\n        this.id=id;\r\n        this.name=name;\r\n        this.next=null;\r\n    }\r\n}\r\n```\r\n\r\nEmpLinkList类，链表\r\n\r\n```java\r\nclass EmpLinkList{\r\n    private Emp head;\r\n    //添加\r\n    public void add(Emp emp){\r\n        if (head==null){\r\n            head=emp;\r\n            return;\r\n        }\r\n        Emp curEmp = head;\r\n        while (curEmp.next!=null){\r\n            curEmp=curEmp.next;\r\n        }\r\n        curEmp.next=emp;\r\n    }\r\n    //遍历\r\n    public void list(){\r\n        if (head==null){\r\n            System.out.println(\"链表为空\");\r\n        }\r\n        Emp curEmp = head;\r\n        while (curEmp!=null){\r\n            System.out.println(\"id:\"+curEmp.id+\"  name:\"+curEmp.name);\r\n            curEmp=curEmp.next;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nHashTab类,哈希表\r\n\r\n```java\r\nclass HashTab{\r\n    private EmpLinkList[] empLinkLists;\r\n    private int size;\r\n    public HashTab(int size){\r\n        this.size=size;\r\n        empLinkLists = new EmpLinkList[size];\r\n        for (int i = 0; i < size; i++) {\r\n            empLinkLists[i] = new EmpLinkList();//这是个坑，注意初始化\r\n        }\r\n    }\r\n	//添加\r\n    public void add(Emp emp){\r\n        empLinkLists[hashFun(emp.id)].add(emp);\r\n    }\r\n	//遍历\r\n    public void list(){\r\n        for (int i = 0; i < size; i++) {\r\n            empLinkLists[i].list();\r\n        }\r\n    }\r\n	//散列\r\n    public int hashFun(int id){\r\n        return id % size;\r\n    }\r\n}\r\n```\r\n\r\n主函数\r\n\r\n```java\r\npublic class HashTableDemo {\r\n    public static void main(String[] args) {\r\n        HashTab hashTab = new HashTab(7);\r\n        Emp emp1 = new Emp(1, \"aaa\");\r\n        Emp emp2 = new Emp(2, \"bbb\");\r\n        hashTab.add(emp1);\r\n        hashTab.add(emp2);\r\n        hashTab.list();\r\n        ArrayList arrayList = new ArrayList(5);\r\n    }\r\n}\r\n```\r\n\r\n测试结果\r\n\r\n```\r\n链表为空\r\nid:1  name:aaa\r\nid:2  name:bbb\r\n链表为空\r\n链表为空\r\n链表为空\r\n链表为空\r\n```','2019-12-15 19:55:48','二分查找，插值查找，斐波那契查找，哈希表的简单实现','https://images.freeimages.com/images/premium/small-comps/2908/29082506-padua-prato-della-valle.jpg','','','','','查找与哈希表','2019-12-15 19:55:48',19,1,3),(25,NULL,NULL,'# 汇编语言与微机原理\r\n\r\n## 微型计算机基础\r\n\r\n### 1.1 微型计算机系统简介\r\n\r\n微处理器，存储器，输入输出，总线构成\r\n\r\n微型计算机系统是总线结构的计算机系统。总线是计算机系统中互连各个部件的一组公用信号线，负责各部件之间的信息传送。系统总线分为地址总线，数据总线，控制总线。\r\n\r\n微处理器通过总线与存储器、i/o设备连接成一个整体。\r\n\r\n### 1.2 计算机中的数制\r\n\r\n数码、基数、位权、表现形式（D/10，B/2，H/16）\r\n\r\n> 数制转换\r\n> 1.非十进制转换为十进制\r\n> 2.十进制到非十进制数的转换\r\n> 3.二进制数与十六进制数之间的转换\r\n> 4.二进制数与八进制数的转换\r\n\r\n### 1.3 二进制整数的算数运算\r\n\r\n#### 二进制数的算术运算规则\r\n\r\n- 加法运算\r\n\r\n- 减法运算\r\n\r\n- 乘法运算\r\n\r\n  移位加\r\n\r\n- 除法运算\r\n\r\n#### 无符号数的表示范围\r\n\r\n- 一个8位无符号数，表示范围 0 ~ 255\r\n- 一个16位无符号数，表示范围  0 ~ 65535\r\n- 一个n位无符号数，表示范围 0 ~ 2……n\r\n\r\n最高位向前有进位或错位，则运算结果产生溢出\r\n\r\n#### 带符号数的表示方法\r\n\r\n- 原码\r\n\r\n  符号位：正数0 负数1 \r\n\r\n  “0” 有+0 和 -0 之分，即数值0的表示不唯一\r\n\r\n  8位取值范围-127~127\r\n\r\n- 反码\r\n\r\n  正数反码与原码相同，负数的反码是将其原码的符号位不变其余各位按位取反\r\n\r\n  “0” 有+0 和 -0 之分，即数值0的表示不唯一\r\n\r\n  +0 原码 00000 0000  反码 00000 0000\r\n\r\n  -0  原码 10000 0000  反码 11111 1111\r\n\r\n  8位取值范围-127~127 \r\n\r\n- 补码\r\n\r\n  正数的补码与原码相同，负数的补码是反码+1\r\n\r\n  -0  原码 10000 0000  反码 11111 1111  补码 00000 0000\r\n\r\n  “0” 唯一\r\n\r\n  -127 原码 11111 1111 反码 10000 0000 补码 10000 0001\r\n\r\n  -128 补码 11000 0000\r\n\r\n  8位取值范围-128~127 \r\n\r\n  > 补码转换为真值方法\r\n  >\r\n  > 1. 符号位不变，数据位取反+1转为原码，再转换为真值\r\n  > 2. 8位补码最高位权为-128，各位位权相加得到真值\r\n\r\n#### 补码运算\r\n\r\n[x+y]补 = [X]补+[Y]补\r\n\r\n[x-y]补 = [X]补+[-Y]补\r\n\r\n[-Y]补 = 对[Y]补求变补，即对[Y]补的每一位包括符号位在内，按位取反并加1\r\n\r\n#### 带符号数的溢出\r\n\r\n同符号数相加或者异符号数相减有可能产生溢出\r\n\r\n最高位和次高位进位异或为1 则溢出\r\n\r\n溢出时，微处理器标志寄存器OF位置1\r\n\r\n### 1.4 浮点数\r\n\r\n单精度（4字节）、双精度（8字节）\r\n\r\n单精度：31位：符号位，23 ~30:阶码、指数，0~22:尾数\r\n\r\n双精度：63位：符号位，52 ~62:阶码、指数，0~51:尾数\r\n\r\n- 尾数只存储了小数部分，1省略\r\n- 阶码是以移码的形式存放。单精度格式中偏移量位127（0111 1111），双精度格式中偏移量为1023（0111 1111 1111 1111）。存储阶码前，阶码要加上偏移量。\r\n\r\n### 1.5 基本逻辑运算与常用逻辑部件\r\n\r\n#### 基本逻辑运算\r\n\r\n- 与\r\n- 或 （v）\r\n- 非 \r\n- 异或（+）\r\n\r\n#### 基本逻辑门\r\n\r\n- 与门\r\n- 或门（>=1）\r\n- 非门\r\n- 异或门（半加器）\r\n- 与非门\r\n- 或非门\r\n- 三态门（具有高阻态）\r\n\r\n### 1.6 编码\r\n\r\n1. ASCII码\r\n\r\n   数字0-9：30H- 39H ，对应的十进制数为48 - 57.\r\n\r\n   26个大写字母：41H-5AH，对应的十进制数为65 - 90\r\n\r\n   26个小写字母：61H-7AH，对应的十进制数为97 - 122\r\n\r\n2. Unicode编码\r\n\r\n   2个字节存放一个字符\r\n\r\n3. BCD码\r\n\r\n   - 压缩（8421码）\r\n   - 非压缩（1个字节）\r\n\r\n## 2.8086/8088微处理器的功能结构\r\n\r\n8088与8086同属都三代16位微处理器。\r\n\r\n8086的数据总线宽度为16位，8088的数据总线宽度为8位。\r\n\r\n8086的指令队列长度为16位，8088的指令队列长度为8位。\r\n\r\n- EU控制部件：控制器。\r\n- ALU：算数逻辑运算单元\r\n- FLAGS：标志寄存器（CF，OF）\r\n- 寄存器组\r\n\r\n执行单元EU：译码分析指令，执行指令，暂存中间结果并保留结果特征。\r\n\r\n总线接口单元BIU：负责CPU与内存或输入输出接口之间的信息传送。取指令，取操作数，保存运算结果。\r\n\r\n8086/8088 CPU为并行工作方式：\r\n\r\n1. EU从BIU的指令队列中去指令并执行指令\r\n2. 在EU执行指令期间，BIU可以取指令放在指令队列中\r\n\r\n### 2.1 8088CPU的引脚\r\n\r\n最小模式：\r\n\r\n- AD7～AD0：8088 地址/数据分时复用总线（address/data bus），双向，三态。\r\n- A15～A8：8 位地址信号，输出，三态。在整个总线周期内提供存储器高 8 位地址。\r\n- A19/S6～A16/S3：分时复用地址/状态总线（address/status bus），输出，三态。提供地址信号A19～A16 及状态位 S6～S3。\r\n- ALE：地址锁存允许信号，ALE=1\r\n- IO/M̅：输入输出存储器控制信号。=1，访问输入输出端口；=0，访问存储器\r\n- 地址/状态复用：S6=0；S5=IF；S4S3=00，ES；S4S3=01，SS；S4S3=10，CS；S4S3=11，DS；\r\n- DEN：数据使能信号，数据总线上有有效数据。\r\n- DT/R：数据传送方向控制信号，=1，CPU发送数据；=0，CPU接收数据。\r\n- WR(非)：写控制信号\r\n- RD(非)：读控制信号\r\n- INTR：可屏蔽中断请求输入端。中断请求（interrupt request）信号，输入，用来申请一个硬件中断。当 IF=1 时，若INTR 保持高电平，则 8088 在当前指令执行完毕后就进入中断响应周期（̅INTA ̅̅̅̅̅̅变为有效）。\r\n- NMI：非屏蔽中断请求输入端\r\n- INTA(非)：对INTR信号的响应\r\n- HOLD：总线保持信号（DMA）\r\n- HLDA：保持响应信号\r\n- RESET：复位信号\r\n- READY：就绪信号（输入）\r\n- TEST：测试信号\r\n\r\n### 2.2 CPU的总线时序\r\n\r\nT：200ns\r\n\r\n### 2.3 8088CPU系统总线形成\r\n\r\n最小模式：单处理机模式\r\n\r\n最大模式：多处理器系统\r\n\r\n三个8282锁存器 一个8286缓冲器组成\r\n\r\n8282是带三态输出的8D锁存器：\r\n\r\n- 8个数据输入端和8个数据输出端\r\n- 控制信号STB：=1，数据输入端数据锁存。与ALE信号连接\r\n- 输出使能OE：=0，从数据输出的输出锁存的数据\r\n\r\n8286是数据总线收发器：\r\n\r\n- A7~A0和B7~B0和，它们既可作输入也可做输出。\r\n- T：数据传送方向控制端，T=1，数据从A→B\r\n- OE：数据使能\r\n\r\n### 3.1 8088CPU的存储器组织--分段管理\r\n\r\n程序中使用的存储器地址是由段基址和段内偏移地址组成，称为逻辑地址。逻辑地址通常写成XXXXH：YYYYH的形式，其中XXXXH为段基址，YYYYH为段内偏移地址。\r\n\r\n物理地址 = 段基址 * 10H + 段内偏移地址\r\n\r\n各段地址范围：首地址+FFFFH\r\n\r\n### 3.2 8088CPU的编程结构\r\n\r\n通用寄存器：\r\n\r\n- AX：累加器。多用于存放中间运算结果\r\n- BX：基址寄存器。用于内存单元的偏移地址\r\n- CX：计数寄存器。用于在循环或串操作指令中存放循环次数或重复次数\r\n- DX：数据寄存器。\r\n- SP：堆栈寄存器，其内容为栈顶的偏移地址\r\n- BP：基址指针寄存器，通常用于堆栈段，与SS搭配使用\r\n- SI：源变址寄存器\r\n- DI：目标变址寄存器\r\n\r\n段寄存器：\r\n\r\n- CS：代码寄存器\r\n- DS：数据寄存器\r\n- ES：附加寄存器\r\n- SS：堆栈寄存器\r\n\r\n控制寄存器：\r\n\r\n- IP：下一条要执行的指令的偏移量\r\n- FLAGS：状态标志寄存器，16位，8088使用了9位。状态标志：6位（CF,SF,AF,PF,OF,ZF），控制标志：3位(IF,TF,DF)\r\n\r\n> - CF：进位标志。算数运算有进位CF=1\r\n> - PF：奇偶标志。运算结果中1的个数为偶数PF=1\r\n> - AF：辅助进位标志。第三位向第四位有进位时AF=1\r\n> - ZF：零标志。运算结果为0，ZF=1\r\n> - SF：符号标志位。运算结果为负数时SF=1\r\n> - OF：溢出标志位。运算结果超出规定范围OF=1\r\n> - IF：中断允许标志。IF=1中断允许\r\n> - DF：方向标志。DF=0地址加1\r\n> - TF：跟踪标志。TF=1为单步工作方式\r\n\r\n','2020-03-07 16:54:49','汇编语言与微机原理网课笔记','https://66.media.tumblr.com/f632bff2c0f8bf6d47cda7e719f9cfe1/tumblr_o30senfBzf1u60tx6o1_1280.jpg','','','','','汇编语言与微机原理','2020-03-07 16:54:49',0,1,3);
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog_tags`
--

DROP TABLE IF EXISTS `t_blog_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog_tags`
--

LOCK TABLES `t_blog_tags` WRITE;
/*!40000 ALTER TABLE `t_blog_tags` DISABLE KEYS */;
INSERT INTO `t_blog_tags` VALUES (8,7),(14,15),(14,1),(16,15),(16,1),(17,15),(17,1),(18,15),(18,1),(19,15),(19,1),(20,1),(20,4),(20,7),(21,15),(21,1),(22,1),(23,1),(23,15),(25,24);
/*!40000 ALTER TABLE `t_blog_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nick_name` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
INSERT INTO `t_tag` VALUES (1,'java'),(3,'spring'),(4,'mysql'),(5,'docker'),(6,'js'),(7,'linux'),(15,'数据结构'),(24,'大学课程');
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_type`
--

DROP TABLE IF EXISTS `t_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_type`
--

LOCK TABLES `t_type` WRITE;
/*!40000 ALTER TABLE `t_type` DISABLE KEYS */;
INSERT INTO `t_type` VALUES (1,'学习笔记'),(2,'生活感悟');
/*!40000 ALTER TABLE `t_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nick_name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (3,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570700205&di=009e9ae45204dddbae89fae8c99f9b42&imgtype=jpg&er=1&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201712%2F18%2F20171218161237_CTtrw.jpeg','2019-09-22 21:30:32','1402285087@qq.com','月光','1eba718e6e7565dd9a5c9c0791ada932',1,'2019-09-22 21:30:35','wende');
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-03-07 17:09:02
